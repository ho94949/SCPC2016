Brief Solution
#1 (Implementation)
63개밖에 안되서 DB를 사용하면 된다.
입력이 K일때 최댓값은 2^K 이고,
K가 63일때 unsigned long long 을 사용해야 함에 주의
최솟값은 반복문을 돌리면서 찾아도 된다.

#2 (Dynamic Programming)
다음과 같은 DP배열을 세우자.
D[i][j] 는 i번째 돌을 밟고 있을때, 지난번 건너온게 j만큼 돌을 뛰어서 건너옴
D[i][j] 를 계산할때는 i-j번째 돌에서만 건너오므로, D[i-j][0] + D[i-j][1]+... 에다가
D[i-j][j] 를 빼서 저격수의 경우를 배제 해 줄 수 있다.
시간복잡도를 낮추기 위해서 D[i][0] + D[i][1] + .. + D[i][K] 를 관리하는 배열을 사용할 수 있다.

#3 (Greedy?)
어떤 정점의 deg가 K 이하라면, 그 컴퓨터는 다른 컴퓨터를 없애는 것으로는 조건을 만족하지 못한다.
그래서 그런 컴퓨터를 없앤다.
어떤 컴퓨터가 감염되었을 때, 감염이 안되는 컴퓨터가 L개 이하라면, 위와 같다.
(연결된 컴퓨터를 없애면 변화가 없고, 연결되지 않은 컴퓨터를 없애면, 감염이 안되는 컴퓨터가 줄어듦)
그래서 그런 컴퓨터를 없앤다.
같은 방법으로 그런 컴퓨터가 없을 때 까지 반복하면, 답을 얻어 낼 수 있다.

#4 (Dijkstra)
시작점이 여러개인 다익스트라 문제이다. 큐에 관리하는 정보를 (현재 위치, 거리, 시작점) 으로 잡고,
역순으로 (a->b 거리와 b->a거리는 같음) 다익스트라를 돌리면 된다.
초기조건은 (대피소, 0, 대피소)로 해서, 어떤 대피소인지 말해줄 수 있다.

#5 (Greedy)
매 시간마다 할 수 있는 행동 중에서 "가장 여유로운 날 수가 적은 것"을 택해서 먼저 한다.
예를들어 현재 시간이 2이고, 끝나는 시간이 5이고, 필요한 일 수가 1 이면,
여유로운 날 수는 (5-2)-1 = 2 이다.
이 기준으로 매 순간마다 최적의 선택을 하면 된다.